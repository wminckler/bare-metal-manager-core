/*
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 *  Code for working the measurement_bundles and measurement_bundles_values
 *  tables in the database, leveraging the bundle-specific record types.
*/

use std::collections::{BTreeMap, HashMap};

use carbide_uuid::machine::MachineId;
use carbide_uuid::measured_boot::{MeasurementBundleId, MeasurementSystemProfileId};
use itertools::Itertools;
use measured_boot::bundle::MeasurementBundle;
use measured_boot::journal::MeasurementJournal;
use measured_boot::pcr::PcrRegisterValue;
use measured_boot::records::{
    MeasurementBundleRecord, MeasurementBundleState, MeasurementBundleValueRecord,
};
use sqlx::{PgConnection, PgTransaction};

use crate::db_read::DbReader;
use crate::measured_boot::interface::bundle::{
    delete_bundle_for_id, delete_bundle_values_for_id, get_machines_for_bundle_id,
    get_measurement_bundle_by_id, get_measurement_bundle_for_name, get_measurement_bundle_records,
    get_measurement_bundle_records_for_profile_id, get_measurement_bundle_values_for_bundle_id,
    insert_measurement_bundle_record, insert_measurement_bundle_value_records,
    rename_bundle_for_bundle_id, rename_bundle_for_bundle_name, update_state_for_bundle_id,
};
use crate::measured_boot::interface::common;
use crate::measured_boot::interface::common::{
    acquire_advisory_txn_lock, pcr_register_values_to_map,
};
use crate::measured_boot::interface::report::match_latest_reports;
use crate::measured_boot::machine::bundle_state_to_machine_state;
use crate::{DatabaseError, DatabaseResult};

pub async fn new(
    txn: &mut PgTransaction<'_>,
    profile_id: MeasurementSystemProfileId,
    name: Option<String>,
    values: &[PcrRegisterValue],
    state: Option<MeasurementBundleState>,
) -> DatabaseResult<MeasurementBundle> {
    // Acquire an advisory lock (automatically released at the end of the txn),
    // whose hash key is generated by the PCR indexes + valuees, ensuring that a duplicate
    // bundle cannot be created during this time.
    acquire_advisory_txn_lock(txn, &pcr_values_to_string(values)).await?;

    if has_exact_from_values(txn, profile_id, values).await? {
        return Err(DatabaseError::AlreadyFoundError {
            kind: "MeasurementBundle",
            id: String::from("(with same bundle values)"),
        });
    }

    let bundle_name = match name {
        Some(name) => name,
        None => common::generate_name()?,
    };

    let info = insert_measurement_bundle_record(txn, profile_id, bundle_name.clone(), state)
        .await
        .map_err(|sqlx_err| {
            let is_db_err = sqlx_err.as_database_error();
            match is_db_err {
                Some(db_err) => match db_err.kind() {
                    sqlx::error::ErrorKind::UniqueViolation => DatabaseError::AlreadyFoundError {
                        kind: "MeasurementBundle",
                        id: bundle_name.clone(),
                    },
                    sqlx::error::ErrorKind::NotNullViolation => DatabaseError::internal(format!(
                        "bundle missing not null value: {} (msg: {})",
                        bundle_name.clone(),
                        db_err
                    )),
                    _ => DatabaseError::new("MeasurementBundle.new db_err", sqlx_err),
                },
                None => DatabaseError::new("MeasurementBundle.new sqlx_err", sqlx_err),
            }
        })?;

    let bundle_values =
        insert_measurement_bundle_value_records(txn, info.bundle_id, values).await?;
    let bundle = from_info_and_values(info, bundle_values)?;
    update_journal(&bundle, txn).await?;

    Ok(bundle)
}

/// from_info_and_values creates a new bundle from the
/// base record and its values.
pub fn from_info_and_values(
    info: MeasurementBundleRecord,
    values: Vec<MeasurementBundleValueRecord>,
) -> DatabaseResult<MeasurementBundle> {
    Ok(MeasurementBundle {
        bundle_id: info.bundle_id,
        profile_id: info.profile_id,
        name: info.name,
        ts: info.ts,
        state: info.state,
        values,
    })
}

/// from_id returns a fully populated instance of
/// MeasurementBundle for the provided `bundle_id`.
pub async fn from_id(
    txn: &mut PgConnection,
    bundle_id: MeasurementBundleId,
) -> DatabaseResult<MeasurementBundle> {
    match get_measurement_bundle_by_id(&mut *txn, bundle_id).await? {
        Some(info) => {
            let values = get_measurement_bundle_values_for_bundle_id(txn, info.bundle_id).await?;
            Ok(from_info_and_values(info, values)?)
        }
        None => Err(DatabaseError::NotFoundError {
            kind: "MeasurementBundle",
            id: bundle_id.to_string(),
        }),
    }
}

/// from_name returns a fully populated instance of
/// MeasurementBundle for the provided `bundle_name`.
pub async fn from_name(
    txn: &mut PgConnection,
    bundle_name: String,
) -> DatabaseResult<MeasurementBundle> {
    match get_measurement_bundle_for_name(txn, bundle_name.clone()).await? {
        Some(info) => {
            let values = get_measurement_bundle_values_for_bundle_id(txn, info.bundle_id).await?;
            Ok(from_info_and_values(info, values)?)
        }
        None => Err(DatabaseError::NotFoundError {
            kind: "MeasurementBundle",
            id: bundle_name.clone(),
        }),
    }
}

/// set_state_for_id sets the bundle state for
/// the given bundle ID.
pub async fn set_state_for_id(
    txn: &mut PgTransaction<'_>,
    bundle_id: MeasurementBundleId,
    state: MeasurementBundleState,
) -> DatabaseResult<MeasurementBundle> {
    let info = set_state_for_bundle_id(txn, bundle_id, state).await?;
    let values = get_measurement_bundle_values_for_bundle_id(txn.as_mut(), info.bundle_id).await?;
    let bundle = from_info_and_values(info, values)?;
    update_journal(&bundle, txn).await?;
    Ok(bundle)
}

/// get_all returns all populated MeasurementBundle
/// models from records in the database.
pub async fn get_all<DB>(txn: &mut DB) -> DatabaseResult<Vec<MeasurementBundle>>
where
    for<'db> &'db mut DB: DbReader<'db>,
{
    let mut res: Vec<MeasurementBundle> = Vec::new();
    let mut bundle_records = get_measurement_bundle_records(&mut *txn).await?;
    for bundle_record in bundle_records.drain(..) {
        let values =
            get_measurement_bundle_values_for_bundle_id(&mut *txn, bundle_record.bundle_id).await?;
        res.push(from_info_and_values(bundle_record, values)?);
    }
    Ok(res)
}

/// get_all_for_profile_id returns all populated
/// MeasurementBundle models for a given profile ID.
pub async fn get_all_for_profile_id(
    txn: &mut PgConnection,
    profile_id: MeasurementSystemProfileId,
) -> DatabaseResult<Vec<MeasurementBundle>> {
    let mut res: Vec<MeasurementBundle> = Vec::new();
    let mut bundle_records = get_measurement_bundle_records_for_profile_id(txn, profile_id).await?;
    for bundle_record in bundle_records.drain(..) {
        let values =
            get_measurement_bundle_values_for_bundle_id(&mut *txn, bundle_record.bundle_id).await?;
        res.push(from_info_and_values(bundle_record, values)?);
    }
    Ok(res)
}

/// has_exact_from_values is just a wrapper to make things
/// a little cleaner for potential callers of exact_from_values.
pub async fn has_exact_from_values(
    txn: &mut PgConnection,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> DatabaseResult<bool> {
    match exact_from_values(txn, profile_id, values).await? {
        Some(_) => Ok(true),
        None => Ok(false),
    }
}

/// exact_from_values returns a fully populated instance of
/// MeasurementBundle that exactly matches the provided `values`.
pub async fn exact_from_values(
    txn: &mut PgConnection,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> DatabaseResult<Option<MeasurementBundle>> {
    match match_from_values(txn, profile_id, values).await? {
        Some(bundle) => {
            if bundle.values.len() == values.len() {
                return Ok(Some(bundle));
            }
            Ok(None)
        }
        None => Ok(None),
    }
}

/// match_from_values returns a fully populated instance of
/// MeasurementBundle that matches the provided `values`.
pub async fn match_from_values(
    txn: &mut PgConnection,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> DatabaseResult<Option<MeasurementBundle>> {
    let bundle_id = match match_bundle(txn, profile_id, values).await? {
        Some(bundle_id) => bundle_id,
        None => {
            return Ok(None);
        }
    };
    Ok(Some(from_id(txn, bundle_id).await?))
}

/// delete deletes this bundle.
pub async fn delete(
    measurement_bundle: &MeasurementBundle,
    txn: &mut PgConnection,
    purge_journals: bool,
) -> DatabaseResult<MeasurementBundle> {
    delete_for_id(txn, measurement_bundle.bundle_id, purge_journals).await
}

pub async fn delete_for_id(
    txn: &mut PgConnection,
    bundle_id: MeasurementBundleId,
    purge_journals: bool,
) -> DatabaseResult<MeasurementBundle> {
    // Note that due to relational constraints, values must be
    // deleted before the parent record.
    if purge_journals {
        return Err(DatabaseError::internal(String::from(
            "journal purge not implemented -- TODO",
        )));
    }
    let values = delete_bundle_values_for_id(txn, bundle_id).await?;
    let record = delete_bundle_for_id(txn, bundle_id).await?;
    match record {
        Some(record) => from_info_and_values(record, values),
        None => Err(DatabaseError::NotFoundError {
            kind: "MeasurementBundleRecord",
            id: bundle_id.to_string(),
        }),
    }
}

/// rename_for_id renames a MeasurementBundle based on its ID.
pub async fn rename_for_id(
    txn: &mut PgConnection,
    bundle_id: MeasurementBundleId,
    new_bundle_name: String,
) -> DatabaseResult<MeasurementBundle> {
    let info = rename_bundle_for_bundle_id(txn, bundle_id, new_bundle_name.clone()).await?;
    match info {
        Some(info) => from_info_and_values(
            info,
            get_measurement_bundle_values_for_bundle_id(txn, bundle_id).await?,
        ),
        None => Err(DatabaseError::NotFoundError {
            kind: "MeasurementBundleRecord",
            id: bundle_id.to_string(),
        }),
    }
}

/// rename_for_name renames a MeasurementBundle based on its name.
pub async fn rename_for_name(
    txn: &mut PgConnection,
    bundle_name: String,
    new_bundle_name: String,
) -> DatabaseResult<MeasurementBundle> {
    let info =
        match rename_bundle_for_bundle_name(txn, bundle_name.clone(), new_bundle_name.clone())
            .await?
        {
            Some(info) => info,
            None => {
                return Err(DatabaseError::NotFoundError {
                    kind: "MeasurementBundleRecord",
                    id: bundle_name.clone(),
                });
            }
        };
    let values = get_measurement_bundle_values_for_bundle_id(txn, info.bundle_id).await?;
    from_info_and_values(info, values)
}

/// delete_for_name deletes a MeasurementBundle and associated
/// MeasurementBundleValues, returning a fully populated instance of
/// MeasurementBundle of the data that was deleted for `bundle_id`.
pub async fn delete_for_name(
    txn: &mut PgConnection,
    bundle_name: String,
    purge_journals: bool,
) -> DatabaseResult<MeasurementBundle> {
    // Note that due to relational constraints, values must be
    // deleted before the parent record.
    if purge_journals {
        return Err(DatabaseError::internal(String::from(
            "journal purge not supported -- TODO",
        )));
    }
    let bundle = delete(
        &from_name(txn, bundle_name.clone()).await?,
        txn,
        purge_journals,
    )
    .await?;
    Ok(bundle)
}

async fn update_journal(
    measurement_bundle: &MeasurementBundle,
    txn: &mut PgTransaction<'_>,
) -> DatabaseResult<Vec<MeasurementJournal>> {
    let machine_state = bundle_state_to_machine_state(&measurement_bundle.state);

    let reports = match_latest_reports(txn.as_mut(), &measurement_bundle.pcr_values()).await?;
    let mut updates: Vec<MeasurementJournal> = Vec::new();
    for report in reports.iter() {
        let machine = crate::measured_boot::machine::from_id(txn, report.machine_id).await?;
        let discovery_attributes = crate::measured_boot::machine::discovery_attributes(&machine)?;
        let profile =
            crate::measured_boot::profile::match_from_attrs_or_new(txn, &discovery_attributes)
                .await?;

        // Don't update journal entries for profiles
        // that aren't mine, since, in theory, two
        // different profiles could have the same
        // golden measurement bundles.
        if profile.profile_id != measurement_bundle.profile_id {
            continue;
        }
        updates.push(
            crate::measured_boot::journal::new(
                txn,
                report.machine_id,
                report.report_id,
                Some(profile.profile_id),
                Some(measurement_bundle.bundle_id),
                machine_state,
            )
            .await?,
        );
    }
    Ok(updates)
}

pub fn intersects(
    measurement_bundle: &MeasurementBundle,
    values: &[PcrRegisterValue],
) -> DatabaseResult<bool> {
    let register_map = pcr_register_values_to_map(values)?;
    Ok(measurement_bundle.values.iter().all(|value_record| {
        if let Some(register_value) = register_map.get(&value_record.pcr_register) {
            register_value.sha_any == value_record.sha_any
        } else {
            false
        }
    }))
}

/// get_machines returns a vector of MachineIds currently
/// associated with this bundle.
pub async fn get_machines(
    measurement_bundle: &MeasurementBundle,
    txn: &mut PgConnection,
) -> DatabaseResult<Vec<MachineId>> {
    get_machines_for_bundle_id(txn, measurement_bundle.bundle_id).await
}

/// match_bundle takes a map of k/v pairs and returns a singular matching
/// bundle ID based on the exact k/v pairs and the number of pairs, should
/// one exist.
///
/// The code is written as such to only allow one bundle to match, so if two
/// matching bundles end up matching, it's because someone was messing around
/// in the tables (or there's a bug).
async fn match_bundle(
    txn: &mut PgConnection,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> DatabaseResult<Option<MeasurementBundleId>> {
    // NOTE(chet): Here is a story!
    //
    // Just for reference, when there was a fixed set of values throughout
    // the codebase (e.g. PCR_VALUE_LENGTH was fixed at 7), this function
    // used to be as simple as the single line of code below. But, once it
    // was decided that the client could send a variable journal size, and
    // that an operator could approve which values to pull into a bundle,
    // it became slightly more complex, since then it went from matching a
    // journal -> bundle to finding bundles which intersected with the
    // provided journal.
    //
    // Ok(get_measurement_bundle_ids_by_values(txn, values).await?)
    //
    // The reason is I could just do where values in ((0,v1), (1,v2), ...),
    // and know there was always a distinct match against 7 values, easy
    // peasy. It's not like that anymore, and that's ok, but it does result
    // in a little more code.

    // Get all bundles, and figure out which *active* bundles intersect
    // with the provided journal. After that, we'll attempt to find the
    // most specific match (if there are multiple matches).

    let all_bundles = get_all_for_profile_id(txn, profile_id).await?;

    let mut matching = get_matching_bundles(&all_bundles, values)?;
    // If there are no matching bundles, or a single matching
    // bundle, it's simple to handle here.
    if matching.is_empty() {
        return Ok(None);
    } else if matching.len() == 1 {
        return Ok(Some(matching[0].bundle_id));
    }

    // Otherwise, sort by the number of bundle values
    // in the bundle, and return the most specific bundle
    // match (as in, the most unique values, if there is
    // one). If there's a conflict, then return an error.
    matching.sort_by(|a, b| b.values.len().cmp(&a.values.len()));
    if matching[0].values.len() == matching[1].values.len() {
        return Err(DatabaseError::internal(String::from(
            "cannot determine most specific bundle match",
        )));
    }

    Ok(Some(matching[0].bundle_id))
}

/// set_state_for_bundle_id sets a new state for a given bundle ID.
pub async fn set_state_for_bundle_id(
    txn: &mut PgConnection,
    bundle_id: MeasurementBundleId,
    state: MeasurementBundleState,
) -> Result<MeasurementBundleRecord, DatabaseError> {
    match update_state_for_bundle_id(txn, bundle_id, state, false).await? {
        // Got a record back, which means the state was successfully
        // updated, so return it.
        Some(record) => Ok(record),

        // Didn't get one back, which means something happened, as in
        // either the bundle didn't exist, or the state is set to
        // revoked. If it's neither of those cases, that's fun.
        None => match get_measurement_bundle_by_id(txn, bundle_id).await? {
            None => Err(DatabaseError::NotFoundError {
                kind: "MeasurementBundleRecord",
                id: bundle_id.to_string(),
            }),
            Some(existing_bundle) => {
                if existing_bundle.state == MeasurementBundleState::Revoked {
                    Err(DatabaseError::internal(format!(
                        "bundle cannot be moved from revoked state: {bundle_id}"
                    )))
                } else {
                    Err(DatabaseError::internal(format!(
                        "totally unknown reason why this happened for bundle: {bundle_id}"
                    )))
                }
            }
        },
    }
}

/// pcr_values_to_string takes a vec of PcrRegisterValue
/// and turns them into a consistent string sorted by PCR
/// register index, as a k:v (pcr_index:pcr_value), separated
/// by commas.
fn pcr_values_to_string(pcr_values: &[PcrRegisterValue]) -> String {
    let sorted_values = pcr_values
        .iter()
        .sorted_by_key(|value| value.pcr_register)
        .collect::<Vec<_>>();

    sorted_values
        .into_iter()
        .map(|value| format!("{}:{}", value.pcr_register, value.sha_any))
        .collect::<Vec<_>>()
        .join(",")
}

pub async fn find_closest_match(
    txn: &mut PgConnection,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> DatabaseResult<Option<MeasurementBundle>> {
    let bundle_id = match find_closest_bundle(txn, profile_id, values).await? {
        Some(bundle_id) => bundle_id,
        None => {
            return Ok(None);
        }
    };
    Ok(Some(from_id(txn, bundle_id).await?))
}

async fn find_closest_bundle(
    txn: &mut PgConnection,
    profile_id: MeasurementSystemProfileId,
    values: &[PcrRegisterValue],
) -> DatabaseResult<Option<MeasurementBundleId>> {
    // FIRST, make sure there are no matching bundles at all
    // but that there are active/obsolete bundles for that profile
    // SECOND, remove all bundles that are subsets: same or less PCR slots
    // AND the same values
    // THIRD, use a BTreeMap and for each bundle specify how many unmasked elements
    // there are in total = (bundle len - elements to remove/mask)
    // FOURTH, always keep the map sorted with the highest number of
    // unmasked elements on top
    // FIFTH, going from the top, do the intersection by leaving the specified
    // amount of unmasked elements, if no match, decrease the number and
    // remove, re-add the bundle to the map
    // repeat the fifth step until the map is empty or until there is a match

    // FIRST
    let all_bundles = get_all_for_profile_id(txn, profile_id).await?;

    let matching = get_matching_bundles(&all_bundles, values)?;
    if !matching.is_empty() {
        let matching_bundle_ids = matching.iter().fold(String::new(), |acc, bundle| {
            acc + " " + bundle.bundle_id.to_string().as_str()
        });
        return Err(DatabaseError::InvalidArgument(format!(
            "Fully matching bundle(s) found: {matching_bundle_ids}"
        )));
    }

    let mut active_bundles = get_active_bundles(&all_bundles);

    if active_bundles.is_empty() {
        tracing::info!(
            "No Active or Obsolete bundles were found for profile_id {0}",
            profile_id
        );
        return Ok(None);
    }

    // SECOND
    remove_all_subsets(&mut active_bundles);

    // THIRD, FOURTH
    let mut ordered_bundles: BTreeMap<usize, Vec<MeasurementBundle>> = BTreeMap::new();

    active_bundles
        .iter()
        .for_each(|elem| add_bundle_to_map(&mut ordered_bundles, elem));

    // FIFTH
    match_closest_bundle(&mut ordered_bundles, values)
}

fn match_closest_bundle(
    ordered_bundles: &mut BTreeMap<usize, Vec<MeasurementBundle>>,
    values: &[PcrRegisterValue],
) -> DatabaseResult<Option<MeasurementBundleId>> {
    // Keep popping off the largest bundles and see
    // if any of them match. If one does, return it!
    while let Some((key, mut bundles)) = ordered_bundles.pop_last() {
        for bundle in &bundles {
            if try_match_masked_bundle(&key, bundle, values)? {
                return Ok(Some(bundle.bundle_id));
            }
        }

        // If unsuccessful, then reinsert the same vector but
        // with a (length - 1) key (either to existing bundles or
        // to a brand new vector).
        //
        // Note: Since key is a usize, use saturating_sub.
        let new_key = key.saturating_sub(1);
        if new_key > 0 {
            ordered_bundles
                .entry(new_key)
                .or_default()
                .append(&mut bundles);
        }
    }

    Ok(None)
}

fn try_match_masked_bundle(
    key: &usize,
    bundle: &MeasurementBundle,
    values: &[PcrRegisterValue],
) -> DatabaseResult<bool> {
    // convert values to hashmap to avoid doing so on every match attempt
    let values_map = pcr_register_values_to_map(values)?;

    // the size of a "sub-bundle" that we will use to for matching
    let match_size = *key;
    let mut sub_bundle_match_array: Vec<MeasurementBundleValueRecord> =
        vec![MeasurementBundleValueRecord::default(); match_size];

    Ok(recursive_match(
        &bundle.values,
        &mut sub_bundle_match_array,
        0,
        &values_map,
    ))
}

// try all unique sub-permutations of bundle_values
// match_array will always be less than bundle_values
//
// Example: given bundle_values: [0, 1, 2] and sub_bundle_match_array
// with capacity 2
// this algorithm with generate the following sub_bundle_match_arrays
// counter == 0 => [0, 1], [0, 2]
// counter == 1 => [1, 2]
// the base condition will be met at counter == 2, where the intersection
// check will be made
fn recursive_match(
    bundle_values: &[MeasurementBundleValueRecord],
    sub_bundle_match_array: &mut Vec<MeasurementBundleValueRecord>,
    counter: usize,
    values_map: &HashMap<i16, PcrRegisterValue>,
) -> bool {
    // base condition - the match_array is full
    // so we need to see if there is a match (intersection)
    if counter == sub_bundle_match_array.capacity() {
        return sub_bundle_intersects(sub_bundle_match_array, values_map);
    }

    for i in 0..bundle_values.len() {
        sub_bundle_match_array[counter] = bundle_values[i].clone();

        if recursive_match(
            &bundle_values[i + 1..],
            sub_bundle_match_array,
            counter + 1,
            values_map,
        ) {
            return true;
        } else {
            continue;
        }
    }

    false
}

// this is the same as intersects(), but slightly optimised
pub fn sub_bundle_intersects(
    match_array: &[MeasurementBundleValueRecord],
    register_map: &HashMap<i16, PcrRegisterValue>,
) -> bool {
    match_array.iter().all(|value_record| {
        if let Some(register_value) = register_map.get(&value_record.pcr_register) {
            register_value.sha_any == value_record.sha_any
        } else {
            false
        }
    })
}

fn add_bundle_to_map(
    ordered_bundles: &mut BTreeMap<usize, Vec<MeasurementBundle>>,
    bundle: &MeasurementBundle,
) {
    // since none of the bundles matched originally, we need to start
    // masking some of their pcr slots and we start with just one
    let key = if bundle.values.len() > 1 {
        bundle.values.len() - 1
    } else {
        // if this is a bundle with just one value and even that did not
        // match, we just exclude it
        return;
    };

    ordered_bundles.entry(key).or_default().push(bundle.clone());
}

// it is rather unlikely that there will be any subsets of a given bundle
// for existing profile, so it's ok to keep it as a vector
fn remove_all_subsets(bundles: &mut Vec<MeasurementBundle>) {
    // 1. sort bundles by len of values in descending order
    // 2. starting with the longest one do the retain algo for each one of the "shorter" bundles
    // 3. if the shorter bundle is the subset, then remove it from the vector

    // 1.
    bundles.sort_by(|a, b| b.values.len().cmp(&a.values.len()));

    // 2.
    let mut indices_to_be_removed = Vec::<usize>::new();
    for (i, senior_bundle) in bundles.iter().enumerate() {
        let senior_values_map: HashMap<i16, String> = senior_bundle
            .pcr_values()
            .iter()
            .map(|v| (v.pcr_register, v.sha_any.clone()))
            .collect();

        for (j, candidate_to_be_removed) in bundles.iter().enumerate().skip(i + 1) {
            // create a hash map out of the values
            // call retain on the hash map, with current_bundle as reference
            // if the hash map is empty, it's a subset - remove it from bundles

            let mut candidate_values_map: HashMap<i16, String> = candidate_to_be_removed
                .pcr_values()
                .iter()
                .map(|v| (v.pcr_register, v.sha_any.clone()))
                .collect();

            candidate_values_map.retain(|k, v| !is_same_kv(k, v, &senior_values_map));
            if candidate_values_map.is_empty() {
                indices_to_be_removed.push(j);
            }
        }
    }

    // 3.
    indices_to_be_removed.sort();
    indices_to_be_removed.dedup();
    // reverse iterator, so that indices wouldn't get shifted due to calling .remove()
    for idx in indices_to_be_removed.iter().rev() {
        bundles.remove(*idx);
    }
}

fn is_same_kv(k: &i16, v: &str, reference_map: &HashMap<i16, String>) -> bool {
    if let Some(value) = reference_map.get(k) {
        value == v
    } else {
        false
    }
}

fn get_active_bundles(bundles: &Vec<MeasurementBundle>) -> Vec<MeasurementBundle> {
    let allowed_states = [
        MeasurementBundleState::Active,
        MeasurementBundleState::Obsolete,
    ];

    let mut active: Vec<MeasurementBundle> = Vec::new();
    for bundle in bundles {
        if allowed_states.contains(&bundle.state) {
            active.push(bundle.clone());
        }
    }

    active
}

fn get_matching_bundles(
    all_bundles: &Vec<MeasurementBundle>,
    values: &[PcrRegisterValue],
) -> DatabaseResult<Vec<MeasurementBundle>> {
    let active = get_active_bundles(all_bundles);

    let mut matching: Vec<MeasurementBundle> = Vec::new();
    for bundle in &active {
        if intersects(bundle, values)? {
            matching.push(bundle.clone());
        }
    }

    Ok(matching)
}

#[cfg(test)]
mod tests {
    use carbide_uuid::measured_boot::MeasurementBundleValueId;

    use super::*;

    const MEASUREMENT_BUNDLE_UUID_1: uuid::Uuid = uuid::Uuid::from_bytes([
        0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
        0xd8,
    ]);

    const MEASUREMENT_BUNDLE_UUID_2: uuid::Uuid = uuid::Uuid::from_bytes([
        0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
        0xa8,
    ]);
    const MEASUREMENT_BUNDLE_UUID_3: uuid::Uuid = uuid::Uuid::from_bytes([
        0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xa7,
        0xa8,
    ]);
    const MEASUREMENT_BUNDLE_UUID_4: uuid::Uuid = uuid::Uuid::from_bytes([
        0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xa6, 0xa7,
        0xa8,
    ]);

    // for the sake of simplicity we just copy the values
    const MEASUREMENT_PROFILE_UUID_1: uuid::Uuid = MEASUREMENT_BUNDLE_UUID_1;

    const MEASUREMENT_RECORD_UUID_1: uuid::Uuid = MEASUREMENT_BUNDLE_UUID_1;
    const MEASUREMENT_RECORD_UUID_2: uuid::Uuid = MEASUREMENT_BUNDLE_UUID_2;
    const MEASUREMENT_RECORD_UUID_3: uuid::Uuid = MEASUREMENT_BUNDLE_UUID_3;

    fn create_generic_bundle(
        bundle_uuid: uuid::Uuid,
        profile_uuid: uuid::Uuid,
        values: Vec<MeasurementBundleValueRecord>,
    ) -> MeasurementBundle {
        MeasurementBundle {
            bundle_id: MeasurementBundleId::from(bundle_uuid),
            profile_id: MeasurementSystemProfileId::from(profile_uuid),
            name: "funny-rabbit".to_string(),
            state: MeasurementBundleState::Active,
            values,
            ts: chrono::DateTime::from_timestamp(1431648000, 0).unwrap(),
        }
    }

    fn create_value_record(
        record_uuid: uuid::Uuid,
        bundle_uuid: uuid::Uuid,
        pcr_register: i16,
        sha_any: &str,
    ) -> MeasurementBundleValueRecord {
        MeasurementBundleValueRecord {
            value_id: MeasurementBundleValueId::from(record_uuid),
            bundle_id: MeasurementBundleId::from(bundle_uuid),
            pcr_register,
            sha_any: sha_any.to_string(),
            ts: chrono::DateTime::from_timestamp(1431648000, 0).unwrap(),
        }
    }

    #[test]
    fn test_remove_all_subsets() {
        // set up
        let mut measurement_bundles = vec![
            create_generic_bundle(
                MEASUREMENT_BUNDLE_UUID_1,
                MEASUREMENT_PROFILE_UUID_1,
                vec![
                    create_value_record(
                        MEASUREMENT_RECORD_UUID_1,
                        MEASUREMENT_BUNDLE_UUID_1,
                        0,
                        "18e93333a0543b6b6192ec5b3ea31e3f05acf31f121855188f9849f9e568c161",
                    ),
                    create_value_record(
                        MEASUREMENT_RECORD_UUID_2,
                        MEASUREMENT_BUNDLE_UUID_1,
                        1,
                        "07aa618176b5874efe473c7ae90c3f9838fa5c3c81c13bf6e78454d4cd546042",
                    ),
                ],
            ),
            create_generic_bundle(
                MEASUREMENT_BUNDLE_UUID_2,
                MEASUREMENT_PROFILE_UUID_1,
                vec![create_value_record(
                    MEASUREMENT_RECORD_UUID_1,
                    MEASUREMENT_BUNDLE_UUID_2,
                    0,
                    "18e93333a0543b6b6192ec5b3ea31e3f05acf31f121855188f9849f9e568c161",
                )],
            ),
            create_generic_bundle(
                MEASUREMENT_BUNDLE_UUID_3,
                MEASUREMENT_PROFILE_UUID_1,
                vec![
                    create_value_record(
                        MEASUREMENT_RECORD_UUID_1,
                        MEASUREMENT_BUNDLE_UUID_3,
                        0,
                        "18e93333a0543b6b6192ec5b3ea31e3f05acf31f121855188f9849f9e568c161",
                    ),
                    create_value_record(
                        MEASUREMENT_RECORD_UUID_2,
                        MEASUREMENT_BUNDLE_UUID_3,
                        1,
                        "07aa618176b5874efe473c7ae90c3f9838fa5c3c81c13bf6e78454d4cd546042",
                    ),
                ],
            ),
        ];
        // execute
        remove_all_subsets(&mut measurement_bundles);
        // verify
        assert_eq!(measurement_bundles.len(), 1);
        println!("Measurement bundle is {:?}", measurement_bundles[0]);
    }

    fn create_bundle_no_matches() -> MeasurementBundle {
        create_generic_bundle(
            MEASUREMENT_BUNDLE_UUID_1,
            MEASUREMENT_PROFILE_UUID_1,
            vec![
                create_value_record(
                    MEASUREMENT_RECORD_UUID_1,
                    MEASUREMENT_BUNDLE_UUID_1,
                    0,
                    "18e93333a0543b6b6192ec5b3ea31e3f05acf31f121855188f9849f9e568c161", // no matches
                ),
                create_value_record(
                    MEASUREMENT_RECORD_UUID_2,
                    MEASUREMENT_BUNDLE_UUID_1,
                    1,
                    "07aa618176b5874efe473c7ae90c3f9838fa5c3c81c13bf6e78454d4cd546042", // no matches
                ),
            ],
        )
    }

    fn create_bundle_one_matching() -> MeasurementBundle {
        create_generic_bundle(
            MEASUREMENT_BUNDLE_UUID_2,
            MEASUREMENT_PROFILE_UUID_1,
            vec![
                create_value_record(
                    MEASUREMENT_RECORD_UUID_1,
                    MEASUREMENT_BUNDLE_UUID_2,
                    0,
                    "18e93333a0543b6b6192ec5b3ea31e3f05acf31f121855188f9849f9e568c161", // non matching
                ),
                create_value_record(
                    MEASUREMENT_RECORD_UUID_2,
                    MEASUREMENT_BUNDLE_UUID_2,
                    1,
                    "07aa618176b5874efe473c7ae90c3f9838fa5c3c81c13bf6e78454d4cd546042", // non matching
                ),
                create_value_record(
                    MEASUREMENT_RECORD_UUID_3,
                    MEASUREMENT_BUNDLE_UUID_2,
                    2,
                    "e90f1be07663d4fbe85248ad906b2ce419aa45acc30d8372f0e6477939851c5b", // matching
                ),
            ],
        )
    }

    fn create_bundle_two_matching() -> MeasurementBundle {
        create_generic_bundle(
            MEASUREMENT_BUNDLE_UUID_3,
            MEASUREMENT_PROFILE_UUID_1,
            vec![
                create_value_record(
                    MEASUREMENT_RECORD_UUID_1,
                    MEASUREMENT_BUNDLE_UUID_3,
                    0,
                    "18e93333a0543b6b6192ec5b3ea31e3f05acf31f121855188f9849f9e568c161", // non matching
                ),
                create_value_record(
                    MEASUREMENT_RECORD_UUID_2,
                    MEASUREMENT_BUNDLE_UUID_3,
                    1,
                    "605fb593f71f163f2537351a6f9dd1aeed89aa9118302ea91b4a9ce672d8c245", // matching
                ),
                create_value_record(
                    MEASUREMENT_RECORD_UUID_3,
                    MEASUREMENT_BUNDLE_UUID_3,
                    2,
                    "e90f1be07663d4fbe85248ad906b2ce419aa45acc30d8372f0e6477939851c5b", // matching
                ),
            ],
        )
    }

    fn create_pcr_register_values() -> [PcrRegisterValue; 5] {
        [
            PcrRegisterValue {
                pcr_register: 0,
                sha_any: "6bc7446ebe68990ca674a8c05321f36a278c5f111f6066fa79aafd4060b7f15f"
                    .to_string(),
            },
            PcrRegisterValue {
                // matching
                pcr_register: 1,
                sha_any: "605fb593f71f163f2537351a6f9dd1aeed89aa9118302ea91b4a9ce672d8c245"
                    .to_string(),
            },
            PcrRegisterValue {
                // matching
                pcr_register: 2,
                sha_any: "e90f1be07663d4fbe85248ad906b2ce419aa45acc30d8372f0e6477939851c5b"
                    .to_string(),
            },
            PcrRegisterValue {
                pcr_register: 5,
                sha_any: "07aa618176b5874efe473c7ae90c3f9838fa5c3c81c13bf6e78454d4cd546042"
                    .to_string(),
            },
            PcrRegisterValue {
                pcr_register: 8,
                sha_any: "605fb593f71f163f2537351a6f9dd1aeed89aa9118302ea91b4a9ce672d8c245"
                    .to_string(),
            },
        ]
    }

    #[test]
    fn test_match_closest_bundle_better_match() {
        let measurement_bundles = vec![
            create_bundle_no_matches(),
            create_bundle_one_matching(),
            create_bundle_two_matching(),
        ];
        // create 5 pcr values
        let pcr_register_values = create_pcr_register_values();

        let mut ordered_bundles: BTreeMap<usize, Vec<MeasurementBundle>> = BTreeMap::new();

        measurement_bundles
            .iter()
            .for_each(|elem| add_bundle_to_map(&mut ordered_bundles, elem));

        // execute and verify
        if let Some(bundle_id) = match_closest_bundle(&mut ordered_bundles, &pcr_register_values)
            .ok()
            .flatten()
        {
            assert_eq!(
                MEASUREMENT_BUNDLE_UUID_3,
                uuid::Uuid::from(bundle_id),
                "Incorrect bundle was selected"
            );
        } else {
            assert_eq!(true, false, "A bundle had to be selected");
        }
    }

    #[test]
    fn test_match_closest_bundle_no_matches() {
        let measurement_bundles = [create_bundle_no_matches()];
        // create 5 pcr values
        let pcr_register_values = create_pcr_register_values();

        let mut ordered_bundles: BTreeMap<usize, Vec<MeasurementBundle>> = BTreeMap::new();

        measurement_bundles
            .iter()
            .for_each(|elem| add_bundle_to_map(&mut ordered_bundles, elem));

        // execute and verify

        assert_eq!(
            None,
            match_closest_bundle(&mut ordered_bundles, &pcr_register_values)
                .ok()
                .flatten()
        );
    }

    #[test]
    fn test_match_closest_bundle_the_only_match() {
        let measurement_bundles = [create_bundle_no_matches(), create_bundle_one_matching()];
        // create 5 pcr values
        let pcr_register_values = create_pcr_register_values();

        let mut ordered_bundles: BTreeMap<usize, Vec<MeasurementBundle>> = BTreeMap::new();

        measurement_bundles
            .iter()
            .for_each(|elem| add_bundle_to_map(&mut ordered_bundles, elem));

        // execute and verify
        if let Some(bundle_id) = match_closest_bundle(&mut ordered_bundles, &pcr_register_values)
            .ok()
            .flatten()
        {
            assert_eq!(
                MEASUREMENT_BUNDLE_UUID_2,
                uuid::Uuid::from(bundle_id),
                "Incorrect bundle was selected"
            );
        } else {
            assert_eq!(true, false, "A bundle had to be selected");
        }
    }

    #[test]
    fn test_match_closest_bundle_two_same_matches() {
        let bundle_one = create_bundle_one_matching();
        let bundle_two = create_generic_bundle(
            MEASUREMENT_BUNDLE_UUID_4,
            MEASUREMENT_PROFILE_UUID_1,
            bundle_one.values.clone(),
        );

        let measurement_bundles = [bundle_one, bundle_two];
        // create 5 pcr values
        let pcr_register_values = create_pcr_register_values();

        let mut ordered_bundles: BTreeMap<usize, Vec<MeasurementBundle>> = BTreeMap::new();

        measurement_bundles
            .iter()
            .for_each(|elem| add_bundle_to_map(&mut ordered_bundles, elem));

        // execute and verify
        if let Some(bundle_id) = match_closest_bundle(&mut ordered_bundles, &pcr_register_values)
            .ok()
            .flatten()
        {
            // the correct bundle just happens to be the first one added
            assert_eq!(
                MEASUREMENT_BUNDLE_UUID_2,
                uuid::Uuid::from(bundle_id),
                "Incorrect bundle was selected"
            );
        } else {
            assert_eq!(true, false, "A bundle had to be selected");
        }
    }

    #[test]
    fn test_pcr_values_to_string() {
        let pcr_values = vec![
            PcrRegisterValue {
                pcr_register: 8,
                sha_any: String::from("ocho"),
            },
            PcrRegisterValue {
                pcr_register: 5,
                sha_any: String::from("cinco"),
            },
            PcrRegisterValue {
                pcr_register: 1,
                sha_any: String::from("uno"),
            },
        ];

        assert_eq!("1:uno,5:cinco,8:ocho", pcr_values_to_string(&pcr_values));
    }
}
