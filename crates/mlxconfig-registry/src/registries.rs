// This file was auto-generated by build.rs
use once_cell::sync::Lazy;

pub static REGISTRIES: Lazy<Vec<mlxconfig_variables::MlxVariableRegistry>> = Lazy::new(|| {
    vec![
        mlxconfig_variables::MlxVariableRegistry::new("mlx_generic")
            .with_filters(
                mlxconfig_device::filters::DeviceFilterSet::new()
                    .with_filter(mlxconfig_device::filters::DeviceFilter::new(mlxconfig_device::filters::DeviceField::DeviceType, vec!["BlueField2".to_string(), "BlueField3".to_string()], mlxconfig_device::filters::MatchMode::Exact))
            )
            .variables(vec![
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("SRIOV_EN".to_string())
                    .description("Enable Single-Root I/O Virtualization (SR-IOV).".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().boolean().build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("NUM_OF_VFS".to_string())
                    .description("The total number of Virtual Functions (VFs) that can be supported, for each PF.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().integer().build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("HIDE_PORT2_PF".to_string())
                    .description("When TRUE, the device will not advertise the PFs associate with port 2, except for the Embedded CPU (ECPF) if exists. This configuration is available only with NV_PCI_CONF.ADVANCED_PCI_SETTINGS is TRUE.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().boolean().build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("NUM_OF_PF".to_string())
                    .description("Total number of Network PCIe functions (PFs) exposed by the device. In case the number of PFs cannot be equally distributed between the number of ports, the remainder of PFs will be distribute between the ports with the lower numbers. For a Multi-Host device, this number is applied to each host individually.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().integer().build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("INTERNAL_CPU_OFFLOAD_ENGINE".to_string())
                    .description("Defines whether the Internal CPU is used as an offload engine.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().enum_type().with_options(vec!["ENABLED".to_string(), "DISABLED".to_string()]).build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("ROCE_ADAPTIVE_ROUTING_EN".to_string())
                    .description("When TRUE, Adaptive Routing for RDMA QPs is supported.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().boolean().build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("USER_PROGRAMMABLE_CC".to_string())
                    .description("When set to TRUE, loading user programmed CC image is enabled. When FALSE, such image cannot be loaded. If an image already exists when this configuration is changed, the image is ignored. Valid only if ROCE_CC_LEGACY_DCQCN is FALSE".to_string())
                    .read_only(true)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().boolean().build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("TX_SCHEDULER_LOCALITY_MODE".to_string())
                    .description("Defines transmission scheduler adaptation to locality.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().enum_type().with_options(vec!["DEVICE_DEFAULT".to_string(), "STATIC_MODE".to_string(), "ACCUMULATIVE".to_string(), "DISABLED".to_string()]).build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("MULTIPATH_DSCP".to_string())
                    .description("Multipath on transmit, set the DSCP bit to hold the MP eligible info.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().enum_type().with_options(vec!["DEVICE_DEFAULT".to_string(), "DISABLE".to_string(), "DSCP_0".to_string(), "DSCP_1".to_string(), "DSCP_2".to_string()]).build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("ROCE_RTT_RESP_DSCP_P1".to_string())
                    .description("The DiffServ Code Point of the generated RTT response for this port. If not set, RTT request value will be used. Overrides PCC_INT_NP_RTT_DSCP.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().integer().build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("ROCE_RTT_RESP_DSCP_MODE_P1".to_string())
                    .description("Defines the method for setting IP.DSCP in RTT response packet. FIXED_VALUE taken from ROCE_RTT_RESP_DSCP, RTT_RQUEST taken from the RTT request.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().enum_type().with_options(vec!["DEVICE_DEFAULT".to_string(), "FIXED_VALUE".to_string(), "RTT_REQUEST".to_string()]).build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("PCI_DOWNSTREAM_PORT_OWNER".to_string())
                    .description("Identifies the owner of the respective PCI Downstream Port.".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().enum_array().with_options(vec!["DEVICE_DEFAULT".to_string(), "EMBEDDED_CPU".to_string(), "HOST_0".to_string(), "HOST_1".to_string(), "HOST_2".to_string(), "HOST_3".to_string(), "HOST_4".to_string(), "HOST_5".to_string(), "HOST_6".to_string(), "HOST_7".to_string()]).with_size(16).build())
                    .build(),
                mlxconfig_variables::MlxConfigVariable::builder()
                    .name("ROCE_CC_STEERING_EXT".to_string())
                    .description("Defines CC extension for packet steering".to_string())
                    .read_only(false)
                    .spec(mlxconfig_variables::MlxVariableSpec::builder().enum_type().with_options(vec!["DEVICE_DEFAULT".to_string(), "DISABLED".to_string(), "ENABLED".to_string()]).build())
                    .build(),
            ]),
]
});

/// get_all returns all hardware configuration registries.
pub fn get_all() -> &'static [mlxconfig_variables::MlxVariableRegistry] {
    &REGISTRIES
}

/// get will return a registry by name.
pub fn get(name: &str) -> Option<&'static mlxconfig_variables::MlxVariableRegistry> {
    REGISTRIES.iter().find(|r| r.name == name)
}

/// list will return a list of all registry names.
pub fn list() -> Vec<&'static str> {
    REGISTRIES.iter().map(|r| r.name.as_str()).collect()
}

/// get_registries_for_device returns all registries that match the given device.
/// If a registry has no filters configured, it matches all devices.
pub fn get_registries_for_device(
    device_info: &mlxconfig_device::info::MlxDeviceInfo,
) -> Vec<&'static mlxconfig_variables::MlxVariableRegistry> {
    REGISTRIES
        .iter()
        .filter(|r| r.matches_device(device_info))
        .collect()
}
